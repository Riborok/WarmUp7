Program WarmUp7;
{
 The program should calculate the division of n numbers in the entered number system
}

{$APPTYPE CONSOLE}

Uses
  System.SysUtils;

Const
  MaxSize=200;
  MaxAmount=50;
  NSAlphabet = '0123456789ABCDEFGHIJ';
  //MaxSize - maximum amount of digits for entered numbers
  //MaxAmount - maximum amount of numbers
  //NSAlphabet - transfer between symbols and numbers

Var
  Num1 :array[1..MaxSize] of SmallInt;
  Num2 :array[1..(MaxSize * MaxAmount)] of SmallInt;
  Num3 :array[1..MaxSize] of SmallInt;
  SuppVar :array[1..(MaxSize * MaxAmount)] of SmallInt;
  str :string;
  MaxNS, NS, Amount, j, Res, CarryRes, Sum, CarrySum : ShortInt;
  Prod, CarryProd, PosElement : Word;
  Len1, Len2, Len3, i, k, l, p, o, DivEl, ToPosEl, CurrPosEl: Word;
  flag, FoundLarger, DelZero, TakeaWay0, RemLessDiv: boolean;
  //Num1 - array of digits of the first number (further the product of the two previous numbers)
  //Num2 - array of digits of the second numbers (with which need to multiply the first number)
  //ProdNums - array of digits of product of numbers (in the process of multiplication)
  //str - string variable for writing numbers
  //MaxNS - maximum number system
  //NS - number system
  //Amount - amount of numbers
  //Sum - sum of all digits in the certain category (for ProdNums)
  //CarrySum - ñarry 1 (if there is) to the next element (for Sum)
  //Len1 - the length of the first number
  //Len2 - the length of the second number
  //Prod - product of the digits of the first and second number
  //CarryProd - ñarry the digit (if there is) to the next element (for Prod)
  //PosElement - the current position of the element in the multiplication
  //i, j, k - cycle counter
  //flag - flag to confirm the correctness of entering numbers

Begin

  MaxNS := length(NSAlphabet);
  Writeln('Enter number system (maximum number system is ',MaxNS,', minimal is 2). The program will calculate their division.');
  Readln(NS);

  Writeln('Enter amount of numbers (no more than ',MaxAmount,' and more than 1)');
  Readln(Amount);

  //Validation of input
  if (NS > MaxNS) or (NS<=1) or (Amount > MaxAmount) or (Amount<=1) then
    Writeln('Incorrect data. Restart the program')
  else
  begin

    //Declaring available symbols and their value
    Writeln;
    Writeln('Available symbols on the ',NS,'th number system and their number system:');
    for i := 0 to (NS-1) do
      Writeln('Symbol ', NSAlphabet[i+1],' Value = ',i);
    Writeln;

    Writeln('Enter numbers (no more than ',MaxSize,' digits).');

    //Cycle with postcondition for entering correct data.
    Repeat

      //Initialize the flag
      flag:= False;

      //Read the first entered number and check for correctness.
      Readln(str);

      //Find length of the first number
      Len1:= length(str);
      if len1>MaxSize then
        flag:= True;

      //Reset the first number for the input
      FillChar(Num1, length(Num1), 0);

      //Write the first entered number in mirrored view to an array
      i:=1;
      while (i<=Len1) and (flag = False) do
      begin

        //Transfer to numerical value (-1 because numbering in delphi starts from 1)
        Num1[i]:= Pos(str[Len1-i+1], NSAlphabet) - 1;

        //Checking for correct input in the number system
        //Num1[i] will be <0 if the symbol is not in NSAlphabet
        if (Num1[i]<0) or (Num1[i]>=NS) then
          flag:= True;

        //Modernize i
        i:= i + 1;
      end;

      if flag = True then
        Writeln('Invalid number entry. Try again');

    Until flag = False;

    Writeln('/');

    //Cycle with postcondition for entering correct data.
    Repeat

      //Initialize the flag
      flag:= False;

      //Read the second number (with which need to add the first number) and check for correctness.
      Readln(str);

      //Find length of the first number
      Len2:= length(str);
      if len2>MaxSize then
        flag:= True;

      //Reset the second number for the input
      FillChar(Num2, length(Num2), 0);

      //Write the second number in mirrored view to an array
      i:=1;
      while (i<=Len2) and (flag = False) do
      begin

        //Transfer to numerical value (-1 because numbering in delphi starts from 1)
        Num2[i]:= Pos(str[Len2-i+1], NSAlphabet) - 1;

        //Checking for correct input in the number system
        //Num2[i] will be <0 if the symbol is not in NSAlphabet
        if (Num2[i]<0) or (Num2[i]>=NS) then
          flag:= True;

        //Modernize i
        i:= i + 1;
      end;

      if flag = True then
        Writeln('Invalid number entry. Try again');

    Until flag = False;










    //The cycle go (Amount-1) times to multiply of all the numbers
    for j := 1 to (Amount-2) do
    begin

      Writeln('/');

      //Cycle with postcondition for entering correct data.
      Repeat

        //Initialize the flag
        flag:= False;

        //Read the second number (with which need to add the first number) and check for correctness.
        Readln(str);

        //Find length of the first number
        Len3:= length(str);
        if len3>MaxSize then
          flag:= True;

        //Reset the second number for the input
        FillChar(Num3, length(Num3), 0);

        //Write the second number in mirrored view to an array
        i:=1;
        while (i<=Len3) and (flag = False) do
        begin

          //Transfer to numerical value (-1 because numbering in delphi starts from 1)
          Num3[i]:= Pos(str[Len3-i+1], NSAlphabet) - 1;

          //Checking for correct input in the number system
          //Num2[i] will be <0 if the symbol is not in NSAlphabet
          if (Num3[i]<0) or (Num3[i]>=NS) then
            flag:= True;

          //Modernize i
          i:= i + 1;
        end;

        if flag = True then
          Writeln('Invalid number entry. Try again');

      Until flag = False;

      //Multiply the digit of the first number by the second number
      for i := 1 to Len2 do
      begin
        for k := 1 to Len3 do
        begin

          //Ñalculate at what position in the multiplication the element now
          PosElement:= k+i-1;

          //Starting to multiply the last digits of the numbers (in the mirrored view it is first)
          //and add the carry (if there is).
          Prod:= Num2[i] * Num3[k] + CarryProd;

          //The integer part of dividing by 10 is the carry that will go to the next element
          CarryProd:= Prod div NS;

          //Find the sum of digits in a current position element
          Sum:= (CarrySum + SuppVar[PosElement] + (Prod mod NS));

          //The integer part of dividing by 10 is the carry that will go to the next element
          CarrySum:= Sum div NS;

          //The modulo of the Sum by 10 is the digit in the c
          SuppVar[PosElement] := Sum mod NS;

          //If there is a carry on the last digit of the second number, then add a carry to the next element
          if k = Len3 then
          begin

            if CarryProd >=1 then
            begin

              //c in the next element is equal to the carry, since this element is new for multiplied
              SuppVar[PosElement+1]:=CarryProd;

              //Carry is assigned 0 for the next iterations
              CarryProd:=0;
            end;

            if CarrySum = 1 then
            begin

              //c in the next element is equal to the sum of carry and c in the next element,
              //since this element was already for added
              SuppVar[PosElement+1]:= CarrySum + SuppVar[PosElement+1];

              //Carry is assigned 0 for the next iterations
              CarrySum:=0;
            end;

          end;
        end;

        //If in the last digits of the two numbers there is a number in the next position,
        //then the current position element increases
        if (i = Len2) and (SuppVar[PosElement+1]>0) then
          PosElement:= PosElement + 1;

      end;

      //For the next iteration, the first number becomes the product of the previous.
      for i := 1 to PosElement do
        Num2[i]:= SuppVar[i];

      //Update the length of the first number
      Len2:= PosElement;

      //Reset the carryes for the operations
      CarrySum:= 0;
      CarryProd:= 0;

      //Reset the product of nums for the iteration
      FillChar(SuppVar, length(SuppVar), 0);

    end;

    if Len2>Len1 then
      flag:= True
    else
    begin

      //Searching the larger number. To do this, we compare the first numbers (in the mirrored view it is last).
      //If they are equal, we move on.
      //If the residual is negative, then there is no need to compare further (since will be the sum of negative numbers)
      i:= Len1;
      FoundLarger:= False;
      while (i>=1) and (FoundLarger = False) do
      begin

        //If a>b, the sign for the first number is '+', for the second '-' (a-b).
        if Num1[i]>Num2[i] then
          FoundLarger:= True

        //If b>a, the sign for the first number is '-', for the second '+' (b-a).
        else if Num2[i]>Num1[i] then
        begin
          //Exit the cycle because we found a larger number.
          FoundLarger:= True;

          flag:= True;
        end;

        //Modernize i
        i:= i - 1;
      end;

    end;

    if flag = True then
      Writeln('The denominator is greater than the numerator! Restart the program')
    else
    begin

      ToPosEl:= Len1 - Len2 + 2;
      CurrPosEl:= len1;

      k:=0;
      repeat

        DelZero:= False;
        i:=CurrPosEl;
        j:= ToPosEl;
        while (i>=j) and (DelZero = False) do
        begin
          if (Num1[i] > 0) then
            DelZero:= True
          else if (CurrPosEl>1) then
          begin
            if (ToPosEl > 1) and (i<>CurrPosEl) then
              ToPosEl:= ToPosEl - 1;
            CurrPosEl:= CurrPosEl - 1;
          end;
          i:=i - 1;
        end;

        if (ToPosEl > 1) and (TakeaWay0 = False) then
          ToPosEl:= ToPosEl - 1;

        k:= k+1;

        DivEl:=0;

        FoundLarger:= False;
        TakeaWay0:= False;

        i:=CurrPosEl;
        l:= Len2;
        while (i>=ToPosEl) and (FoundLarger = False) do
        begin

          if (((CurrPosEl-ToPosEl+1)=Len2) and (Num1[i]>Num2[l])) or ((CurrPosEl-ToPosEl+1)>Len2)
          or ((l = 1) and (Num1[i]=Num2[l])) then
          begin

            CarryRes:=0;
            o:= 1;
            p:= ToPosEl;
            while p<=CurrPosEl do
            begin

              //Considering the signs, starting to subtract the last digits of the numbers (in the mirrored view it is first)
              //and consider the carry (if there is).
              Res:= Num1[p] - Num2[o] + CarryRes;

              //If the difference is less than zero, then we take 1 (for the current digit it is 10) from the next digit
              if Res < 0 then
              begin
                Res:= Res + NS;
                CarryRes:= -1;
              end
              //Else carry = 0
              else
                CarryRes:= 0;

              //Put the result in the residual array c
              Num1[p]:= Res;

              o:= o + 1;
              p:= p + 1;

            end;

            if (Num1[CurrPosEl] = 0) and (CurrPosEl > 1) then
            begin
              i:= CurrPosEl;
              CurrPosEl:= CurrPosEl - 1;
            end
            else
              i:= CurrPosEl + 1;

            DivEl:= DivEl + 1;

            l:= len2 + 1;
          end

          else if ((CurrPosEl-ToPosEl+1)<Len2) or (((CurrPosEl-ToPosEl+1)=Len2) and (Num1[i]<Num2[l])) then
          begin
            FoundLarger:= True;

            if ((CurrPosEl<Len2) or ((CurrPosEl=Len2) and (Num1[i]<Num2[l]))) then
              RemLessDiv:= True;

          end;

          i:= i - 1;
          l:= l - 1;
        end;

        SuppVar[k]:= DivEl;

      until RemLessDiv = True; //ÍÅÏÐÀÂÈËÜÍÎÅ ÓÑËÎÂÈÅ ÂÛÕÎÄÀ

      {if Num1[CurrPosEl]=0 then
      begin
        k:= k + 1;
        CurrPosEl:= CurrPosEl - 1;
      end;}



      Writeln('The prod of the numbers is:');

      //Else write the answer, mirroring the back
      //And transfer to symbolic value (+1 because numbering in delphi starts from 1)

      if SuppVar[1] = 0 then
        i:= 2
      else
        i:= 1;

      k:= k + ToPosEl - 1;

      while i<=k do
      begin
        Write(NSAlphabet[SuppVar[i]+1]);
        i:= i + 1;
      end;

      Writeln;
      Writeln('Remainder after division is:');

      for i:=CurrPosEl downto 1 do
        Write(Num1[i]);
    end;

  end;

  Readln;
End.
